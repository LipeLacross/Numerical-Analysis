# -*- coding: utf-8 -*-
"""Atividade 05 - Ajuste de curva de MMQ

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dtAQxP57kAQnSHwsLLGYpqiPJ2it2vPD

# Atividade — Ajuste de Curvas pelo Método dos Mínimos Quadrados

## Fundamentos Teóricos

O método dos mínimos quadrados para o caso discreto busca encontrar os coeficientes que minimizam a soma dos quadrados dos resíduos:

$$
F(a, b, c) = \sum_{k=1}^{21} \left[y_k - (-34{,}63x_k^2 - 633{,}36x_k + 137.417{,}76)\right]^2
$$

O sistema de equações normais é dado por:

$$
G\alpha = b
$$

onde:
- **$G_{ij} = \langle g_i, g_j \rangle = \sum_{k=1}^{21} g_i(x_k)g_j(x_k)$** (produto interno das funções base)
- **$b_i = \sum_{k=1}^{21} y_k g_i(x_k)$** (projeção dos dados nas funções base)

---

## Descrição

Análise do preço de fechamento do ativo WIN (B3) nos últimos 21 dias com **ajuste polinomial de grau 2** pelo método dos mínimos quadrados.

- **Dados reais:** 21 pontos históricos
- **Curva ajustada:** $\varphi(x) = -34{,}63x^2 - 633{,}36x + 137.417{,}76$
- **Previsão:** $\varphi(1) = 136.749{,}76 \pm 2.537{,}68$

**Intervalo de confiança (95%):**
$$
[134.212; 139.287]
$$

---

## Modelo Matemático (MMQ)

### Formulação Matricial

Para $m = 21$ pontos e $n = 3$ coeficientes:

$$
G = \begin{pmatrix}
\sum 1 & \sum x_k & \sum x_k^2 \\
\sum x_k & \sum x_k^2 & \sum x_k^3 \\
\sum x_k^2 & \sum x_k^3 & \sum x_k^4
\end{pmatrix}, \quad
b = \begin{pmatrix}
\sum y_k \\
\sum y_kx_k \\
\sum y_kx_k^2
\end{pmatrix}
$$

---

## Análise dos Resultados

### Coeficientes e Interpretação

| Parâmetro   | Valor       | Impacto Financeiro         |
|-------------|-------------|----------------------------|
| Quadrático  | $-34{,}63$  | Pressão vendedora crescente|
| Linear      | $-633{,}36$ | Queda diária de 0,46%      |
| Constante   | $137.417{,}76$ | Suporte teórico         |

### Métricas de Qualidade

| Indicador          | Valor        | Fórmula                  |
|--------------------|--------------|--------------------------|
| $R^2$              | $0{,}467$    | $1 - \frac{SS_{res}}{SS_{tot}}$ |
| Erro Padrão ($\sigma$) | $1.268{,}84$ | $\sqrt{\frac{SS_{res}}{18}}$    |
| Volatilidade (2$\sigma$) | $\pm 2.537{,}68$ | Margem de segurança   |

---

## Conclusão

1. **Previsão consistente:** Dentro da faixa histórica de volatilidade  
2. **Eficiência do modelo:** Explica $46{,}7\%$ da variabilidade de preços  
3. **Risco calculado:** Intervalo de confiança de $\pm1{,}85\%$

---

## Referências

- Slides do Prof. Marcos Daniel Nogueira Maia: Fundamentação teórica do MMQ discreto
"""

#Código Final
import numpy as np
import matplotlib.pyplot as plt

# Dados históricos (últimos 21 dias)
x = np.array([-20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8,
              -7, -6, -5, -4, -3, -2, -1, 0])
y = np.array([135665, 135390, 138360, 138220, 138620, 140525, 140065, 141075,
              140325, 141310, 141500, 139060, 136290, 138830, 139420, 140930,
              140285, 139605, 138020, 137434, 138455])

# Ajuste polinomial de grau 2
coef = np.polyfit(x, y, 2)
poly2 = np.poly1d(coef)

# Previsão para amanhã (x=1)
y_pred = poly2(1)
residuos = y - poly2(x)
erro = np.std(residuos)

# Cálculo do R²
SS_res = np.sum((y - poly2(x))**2)
SS_tot = np.sum((y - np.mean(y))**2)
r_squared = 1 - (SS_res / SS_tot)

# Saída dos resultados
print(f"Coeficientes: a = {coef[0]:.2f}, b = {coef[1]:.2f}, c = {coef[2]:.2f}")
print(f"Previsão para amanhã: {y_pred:.2f}")
print(f"Erro estimado: ± {erro:.2f}")
print(f"Intervalo de confiança: [{y_pred-2*erro:.0f}, {y_pred+2*erro:.0f}]")
print(f"Qualidade do ajuste (R²): {r_squared:.3f}")

# Plotagem do gráfico
plt.figure(figsize=(10, 6))
plt.scatter(x, y, color='black', s=50, label='Dados reais')
xx = np.linspace(-20, 1, 200)
plt.plot(xx, poly2(xx), 'red', linewidth=2, label='Ajuste polinomial')
plt.scatter([1], [y_pred], color='green', s=100, label=f'Previsão: {y_pred:.0f}')
plt.xlabel('Dias')
plt.ylabel('Preço')
plt.title('Ajuste MMQ - Preço WIN B3')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

#Código base prof
import numpy as np
import matplotlib.pyplot as plt
y = [
    135665, 135390, 138360, 138220, 138620, 140525, 140065, 141075, 140325,
    141310, 141500, 139060, 136290, 138830, 139420, 140930, 140285, 139605,
    138020, 137434, 138455
]
x = [i-20 for i in range(0,21)]
plt.plot(x,y, 'o')
plt.show

# define as funções a serem ajustadas

g = [lambda r: 1 if isinstance(r, int) else np.ones(len(r)),
     lambda r: np.array(r),
     lambda r: np.pow(r,2),
     lambda r: np.exp(r)]

#dimensão do sistema linear
n = len(g)
#matriz dos coeficientes

G = [[sum(g[i](x)*g[j](x)) for i in range(n)]for j in range(n)]
b = [sum(g[1](x)*y) for i in range(n)]

# Resolve o sistema linear G* a = b
a = np.linalg.solve(G,b)


print(a)

#define  função de ajuste total
def phi(r):
  s = 0
  for i in range(n):
    s += a[i]*g[i](r)
  return s

print(phi(1))
#cria curva
x_aux = np.linspace(min(x), max(x), 100)
y_ajustado = phi(x_aux)
plt.plot(x,y, 'o')
plt.show(x_aux,y_ajustado)

#calcular o erro medio do ajuste
# para cada ponto x_k (tabelado) faça
# erro = abs (y_k - phi(x_k))
#acumula o erro e divide pela quantidade de pontos tabelados