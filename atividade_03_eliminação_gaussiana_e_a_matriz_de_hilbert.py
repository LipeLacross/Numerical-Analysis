# -*- coding: utf-8 -*-
"""Atividade 03 - Eliminação Gaussiana e a Matriz de Hilbert

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1elRIOSPEu-ZQmQdRvCst3J_E04FmJ5Qm

Cálculo Numérico - Atividade 03
Prof. Marcos Daniel Nogueira Maia
13 de Maio de 2025

Considere um sistema linear H x = b cuja matriz dos coeficientes (H) é dada pela matriz de
Hilbert:

Hi j =
1
/ (i + j −1)

e o vetor dos termos independentes é dado pela soma das linhas da matriz dos coeficientes, isto é

bi =
Xn
j=1
Hi j

em que n é a dimensão do sistema linear.
1. Faça os cálculos manualmente (usando a Eliminação Gaussiana) obtendo a solução para o
caso n = 3.
2. Generalize o vetor solução para uma dimensão arbitrária do sistema.
3. Implemente o algoritmo da eliminação gaussiana (sem pivotamento) e teste o programa
para n = 3, n = 10 e n = 100. Interprete os resultados.
4. Calcule numericamente o determinante da matriz dos coeficientes em cada caso (n = 3,
n = 10 e n = 100) usando a matriz escalonada. Associe os resultados obtidos neste item com
os resultados obtidos no item anterior.
"""

# prof v2
import numpy as np

def eliminacao_gaussiana(A, b):
    n = len(b)
    # Eliminação Gaussiana
    for k in range(0, n-1):
        pivo = A[k][k]

        for i in range(k+1, n):
            m = A[i][k] / pivo

            for j in range(k, n):
                A[i][j] -= m * A[k][j]

            b[i] -= m * b[k]

    # Cálculo do determinante (produto dos elementos da diagonal)
    det = 1
    for t in range(n):
        det *= A[t][t]

    return A, b, det

def subs_reversa(A, b):
    n = len(b)
    x = np.zeros(n)
    # Substituição reversa
    for k in range(n-1, -1, -1):
        s = 0
        for j in range(k+1, n):
            s += A[k][j] * x[j]
        x[k] = (b[k] - s) / A[k][k]

    return x

# Função para gerar a matriz de Hilbert de dimensão n
def matriz_hilbert(n):
    return np.array([[1/(i+j-1) for j in range(1, n+1)] for i in range(1, n+1)])

# Testando para n=3
n = 3
H_3 = matriz_hilbert(n)
b_3 = np.sum(H_3, axis=1)

# Aplicando a eliminação gaussiana
A_3, b_3_modificado, det_3 = eliminacao_gaussiana(H_3.copy(), b_3.copy())

# Encontrando a solução através da substituição reversa
solucao_3 = subs_reversa(A_3, b_3_modificado)

print("Matriz escalonada para n=3:")
print(A_3)
print("Solução para n=3:", solucao_3)
print("Determinante para n=3:", det_3)

# Testando para n=10
n = 10
H_10 = matriz_hilbert(n)
b_10 = np.sum(H_10, axis=1)

A_10, b_10_modificado, det_10 = eliminacao_gaussiana(H_10.copy(), b_10.copy())
solucao_10 = subs_reversa(A_10, b_10_modificado)

print("\nMatriz escalonada para n=10:")
print(A_10)
print("Solução para n=10:", solucao_10)
print("Determinante para n=10:", det_10)

# Testando para n=100
n = 100
H_100 = matriz_hilbert(n)
b_100 = np.sum(H_100, axis=1)

A_100, b_100_modificado, det_100 = eliminacao_gaussiana(H_100.copy(), b_100.copy())
solucao_100 = subs_reversa(A_100, b_100_modificado)

print("\nMatriz escalonada para n=100:")
print(A_100)
print("Solução para n=100:", solucao_100)
print("Determinante para n=100:", det_100)

#codigo rascunho prof

def eliminacao_gaussiana(A, b):
  n =len(b)
  for k in range(0, n-1):
    pivo = A[k][k]

    for i in range(k+1, n):
      m = A[i][k] / pivo

      for j in range (k,n):
        A[i][j] - m*A[k][j]

      b[i]= b[i] - m*b[k]
  det = 1
  for t in range(n)
    det = det * A[t][t]
  return A, b, det

  def subs_reversa(A_t,b_t):
    n = len(b_t)
    x = n*[0]
    x[n-1] = b_t[n-1] / A_t[n-1][n-1]

    for k in range(n-2,-1,-1):
      s = 0
      for j in range(k+1, n):
        s = s  A_t[k][j]*x[j]

  #matri de hilbert
  n = 3
  H = [[1/(i+1+j+1-1) for i range(n)] for j in range(n)]
  b = [sum(linhas for linha in H)]

  print()



  x = subs_reversa(H_t)
  print(x)

